/* tslint:disable */
/* eslint-disable */
/*
Svix API

Welcome to the Svix API documentation!

Useful links: [Homepage](https://www.svix.com) | [Support email](mailto:support+docs@svix.com) | [Blog](https://www.svix.com/blog/) | [Slack Community](https://www.svix.com/slack/)

# Introduction

This is the reference documentation and schemas for the [Svix webhook service](https://www.svix.com) API. For tutorials and other documentation please refer to [the documentation](https://docs.svix.com).

## Main concepts

In Svix you have four important entities you will be interacting with:

- `messages`: these are the webhooks being sent. They can have contents and a few other properties.
- `application`: this is where `messages` are sent to. Usually you want to create one application for each user on your platform.
- `endpoint`: endpoints are the URLs messages will be sent to. Each application can have multiple `endpoints` and each message sent to that application will be sent to all of them (unless they are not subscribed to the sent event type).
- `event-type`: event types are identifiers denoting the type of the message being sent. Event types are primarily used to decide which events are sent to which endpoint.


## Authentication

Get your authentication token (`AUTH_TOKEN`) from the [Svix dashboard](https://dashboard.svix.com) and use it as part of the `Authorization` header as such: `Authorization: Bearer ${AUTH_TOKEN}`. For more information on authentication, please refer to the [authentication token docs](https://docs.svix.com/api-keys).




## Code samples

The code samples assume you already have the respective libraries installed and you know how to use them. For the latest information on how to do that, please refer to [the documentation](https://docs.svix.com/).


## Idempotency

Svix supports [idempotency](https://en.wikipedia.org/wiki/Idempotence) for safely retrying requests without accidentally performing the same operation twice. This is useful when an API call is disrupted in transit and you do not receive a response.

To perform an idempotent request, pass the idempotency key in the `Idempotency-Key` header to the request. The idempotency key should be a unique value generated by the client. You can create the key in however way you like, though we suggest using UUID v4, or any other string with enough entropy to avoid collisions.

Svix's idempotency works by saving the resulting status code and body of the first request made for any given idempotency key for any successful request. Subsequent requests with the same key return the same result for a period of up to 12 hours.

Please note that idempotency is only supported for `POST` requests.


## Cross-Origin Resource Sharing

This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with [W3C spec](https://www.w3.org/TR/cors/). And that allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site.


The version of the OpenAPI document: 1.21.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ApplicationIn } from '../models';
// @ts-ignore
import { HTTPValidationError } from '../models';
// @ts-ignore
import { HttpErrorOut } from '../models';
// @ts-ignore
import { ListResponseMessageOut } from '../models';
// @ts-ignore
import { MessageIn } from '../models';
// @ts-ignore
import { MessageOut } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new message and dispatches it to all of the application\'s endpoints.  The `eventId` is an optional custom unique ID. It\'s verified to be unique only up to a day, after that no verification will be made. If a message with the same `eventId` already exists for any application in your environment, a 409 conflict error will be returned.  The `eventType` indicates the type and schema of the event. All messages of a certain `eventType` are expected to have the same schema. Endpoints can choose to only listen to specific event types. Messages can also have `channels`, which similar to event types let endpoints filter by them. Unlike event types, messages can have multiple channels, and channels don\'t imply a specific message content or schema.  The `payload` property is the webhook\'s body (the actual webhook message). Svix supports payload sizes of up to ~350kb, though it\'s generally a good idea to keep webhook payloads small, probably no larger than 40kb.
         * @summary Create Message
         * @param {string} appId The app\&#39;s ID or UID
         * @param {MessageIn} messageIn 
         * @param {boolean} [withContent] When &#x60;true&#x60; message payloads are included in the response
         * @param {string} [idempotencyKey] The request\&#39;s idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewMsg: async (appId: string, messageIn: MessageIn, withContent?: boolean, idempotencyKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createNewMsg', 'appId', appId)
            // verify required parameter 'messageIn' is not null or undefined
            assertParamExists('createNewMsg', 'messageIn', messageIn)
            const localVarPath = `/api/v1/app/{app_id}/msg`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId !== undefined ? appId : `-app_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (withContent !== undefined) {
                localVarQueryParameter['with_content'] = withContent;
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['idempotency-key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: messageIn,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v1/app/{app_id}/msg',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(messageIn, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the given message\'s payload. Useful in cases when a message was accidentally sent with sensitive content.  The message can\'t be replayed or resent once its payload has been deleted or expired.
         * @summary Delete message payload
         * @param {string} appId The app\&#39;s ID or UID
         * @param {string} msgId The msg\&#39;s ID or UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePayload: async (appId: string, msgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deletePayload', 'appId', appId)
            // verify required parameter 'msgId' is not null or undefined
            assertParamExists('deletePayload', 'msgId', msgId)
            const localVarPath = `/api/v1/app/{app_id}/msg/{msg_id}/content`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId !== undefined ? appId : `-app_id-`)))
                .replace(`{${"msg_id"}}`, encodeURIComponent(String(msgId !== undefined ? msgId : `-msg_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v1/app/{app_id}/msg/{msg_id}/content',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a message by its ID or eventID.
         * @summary Get Message
         * @param {string} appId The app\&#39;s ID or UID
         * @param {string} msgId The msg\&#39;s ID or UID
         * @param {boolean} [withContent] When &#x60;true&#x60; message payloads are included in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByIdOrEventId: async (appId: string, msgId: string, withContent?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getByIdOrEventId', 'appId', appId)
            // verify required parameter 'msgId' is not null or undefined
            assertParamExists('getByIdOrEventId', 'msgId', msgId)
            const localVarPath = `/api/v1/app/{app_id}/msg/{msg_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId !== undefined ? appId : `-app_id-`)))
                .replace(`{${"msg_id"}}`, encodeURIComponent(String(msgId !== undefined ? msgId : `-msg_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (withContent !== undefined) {
                localVarQueryParameter['with_content'] = withContent;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v1/app/{app_id}/msg/{msg_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the application\'s messages.  The `before` and `after` parameters let you filter all items created before or after a certain date. These can be used alongside an iterator to paginate over results within a certain window.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
         * @summary List Messages
         * @param {string} appId The app\&#39;s ID or UID
         * @param {number} [limit] Limit the number of returned items
         * @param {string} [iterator] The iterator returned from a prior invocation
         * @param {string} [channel] Filter response based on the channel
         * @param {string} [before] Only include items created before a certain date
         * @param {string} [after] Only include items created after a certain date
         * @param {boolean} [withContent] When &#x60;true&#x60; message payloads are included in the response
         * @param {string} [tag] Filter messages matching the provided tag
         * @param {Set<string>} [eventTypes] Filter response based on the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllMessages: async (appId: string, limit?: number, iterator?: string, channel?: string, before?: string, after?: string, withContent?: boolean, tag?: string, eventTypes?: Set<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listAllMessages', 'appId', appId)
            const localVarPath = `/api/v1/app/{app_id}/msg`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId !== undefined ? appId : `-app_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (iterator !== undefined) {
                localVarQueryParameter['iterator'] = iterator;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = (after as any instanceof Date) ?
                    (after as any).toISOString() :
                    after;
            }

            if (withContent !== undefined) {
                localVarQueryParameter['with_content'] = withContent;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (eventTypes) {
                localVarQueryParameter['event_types'] = Array.from(eventTypes);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v1/app/{app_id}/msg',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new message and dispatches it to all of the application\'s endpoints.  The `eventId` is an optional custom unique ID. It\'s verified to be unique only up to a day, after that no verification will be made. If a message with the same `eventId` already exists for any application in your environment, a 409 conflict error will be returned.  The `eventType` indicates the type and schema of the event. All messages of a certain `eventType` are expected to have the same schema. Endpoints can choose to only listen to specific event types. Messages can also have `channels`, which similar to event types let endpoints filter by them. Unlike event types, messages can have multiple channels, and channels don\'t imply a specific message content or schema.  The `payload` property is the webhook\'s body (the actual webhook message). Svix supports payload sizes of up to ~350kb, though it\'s generally a good idea to keep webhook payloads small, probably no larger than 40kb.
         * @summary Create Message
         * @param {MessageApiCreateNewMsgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewMsg(requestParameters: MessageApiCreateNewMsgRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOut>> {
            const messageIn: MessageIn = {
                tags: requestParameters.tags,
                eventId: requestParameters.eventId,
                eventType: requestParameters.eventType,
                payload: requestParameters.payload,
                channels: requestParameters.channels,
                payloadRetentionPeriod: requestParameters.payloadRetentionPeriod,
                application: requestParameters.application,
                transformationsParams: requestParameters.transformationsParams
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewMsg(requestParameters.appId, messageIn, requestParameters.withContent, requestParameters.idempotencyKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the given message\'s payload. Useful in cases when a message was accidentally sent with sensitive content.  The message can\'t be replayed or resent once its payload has been deleted or expired.
         * @summary Delete message payload
         * @param {MessageApiDeletePayloadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePayload(requestParameters: MessageApiDeletePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePayload(requestParameters.appId, requestParameters.msgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a message by its ID or eventID.
         * @summary Get Message
         * @param {MessageApiGetByIdOrEventIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByIdOrEventId(requestParameters: MessageApiGetByIdOrEventIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByIdOrEventId(requestParameters.appId, requestParameters.msgId, requestParameters.withContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the application\'s messages.  The `before` and `after` parameters let you filter all items created before or after a certain date. These can be used alongside an iterator to paginate over results within a certain window.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
         * @summary List Messages
         * @param {MessageApiListAllMessagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllMessages(requestParameters: MessageApiListAllMessagesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResponseMessageOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllMessages(requestParameters.appId, requestParameters.limit, requestParameters.iterator, requestParameters.channel, requestParameters.before, requestParameters.after, requestParameters.withContent, requestParameters.tag, requestParameters.eventTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageApiFp(configuration)
    return {
        /**
         * Creates a new message and dispatches it to all of the application\'s endpoints.  The `eventId` is an optional custom unique ID. It\'s verified to be unique only up to a day, after that no verification will be made. If a message with the same `eventId` already exists for any application in your environment, a 409 conflict error will be returned.  The `eventType` indicates the type and schema of the event. All messages of a certain `eventType` are expected to have the same schema. Endpoints can choose to only listen to specific event types. Messages can also have `channels`, which similar to event types let endpoints filter by them. Unlike event types, messages can have multiple channels, and channels don\'t imply a specific message content or schema.  The `payload` property is the webhook\'s body (the actual webhook message). Svix supports payload sizes of up to ~350kb, though it\'s generally a good idea to keep webhook payloads small, probably no larger than 40kb.
         * @summary Create Message
         * @param {MessageApiCreateNewMsgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewMsg(requestParameters: MessageApiCreateNewMsgRequest, options?: AxiosRequestConfig): AxiosPromise<MessageOut> {
            return localVarFp.createNewMsg(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the given message\'s payload. Useful in cases when a message was accidentally sent with sensitive content.  The message can\'t be replayed or resent once its payload has been deleted or expired.
         * @summary Delete message payload
         * @param {MessageApiDeletePayloadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePayload(requestParameters: MessageApiDeletePayloadRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePayload(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a message by its ID or eventID.
         * @summary Get Message
         * @param {MessageApiGetByIdOrEventIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByIdOrEventId(requestParameters: MessageApiGetByIdOrEventIdRequest, options?: AxiosRequestConfig): AxiosPromise<MessageOut> {
            return localVarFp.getByIdOrEventId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the application\'s messages.  The `before` and `after` parameters let you filter all items created before or after a certain date. These can be used alongside an iterator to paginate over results within a certain window.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
         * @summary List Messages
         * @param {MessageApiListAllMessagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllMessages(requestParameters: MessageApiListAllMessagesRequest, options?: AxiosRequestConfig): AxiosPromise<ListResponseMessageOut> {
            return localVarFp.listAllMessages(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNewMsg operation in MessageApi.
 * @export
 * @interface MessageApiCreateNewMsgRequest
 */
export type MessageApiCreateNewMsgRequest = {
    
    /**
    * The app\'s ID or UID
    * @type {string}
    * @memberof MessageApiCreateNewMsg
    */
    readonly appId: string
    
    /**
    * When `true` message payloads are included in the response
    * @type {boolean}
    * @memberof MessageApiCreateNewMsg
    */
    readonly withContent?: boolean
    
    /**
    * The request\'s idempotency key
    * @type {string}
    * @memberof MessageApiCreateNewMsg
    */
    readonly idempotencyKey?: string
    
} & MessageIn

/**
 * Request parameters for deletePayload operation in MessageApi.
 * @export
 * @interface MessageApiDeletePayloadRequest
 */
export type MessageApiDeletePayloadRequest = {
    
    /**
    * The app\'s ID or UID
    * @type {string}
    * @memberof MessageApiDeletePayload
    */
    readonly appId: string
    
    /**
    * The msg\'s ID or UID
    * @type {string}
    * @memberof MessageApiDeletePayload
    */
    readonly msgId: string
    
}

/**
 * Request parameters for getByIdOrEventId operation in MessageApi.
 * @export
 * @interface MessageApiGetByIdOrEventIdRequest
 */
export type MessageApiGetByIdOrEventIdRequest = {
    
    /**
    * The app\'s ID or UID
    * @type {string}
    * @memberof MessageApiGetByIdOrEventId
    */
    readonly appId: string
    
    /**
    * The msg\'s ID or UID
    * @type {string}
    * @memberof MessageApiGetByIdOrEventId
    */
    readonly msgId: string
    
    /**
    * When `true` message payloads are included in the response
    * @type {boolean}
    * @memberof MessageApiGetByIdOrEventId
    */
    readonly withContent?: boolean
    
}

/**
 * Request parameters for listAllMessages operation in MessageApi.
 * @export
 * @interface MessageApiListAllMessagesRequest
 */
export type MessageApiListAllMessagesRequest = {
    
    /**
    * The app\'s ID or UID
    * @type {string}
    * @memberof MessageApiListAllMessages
    */
    readonly appId: string
    
    /**
    * Limit the number of returned items
    * @type {number}
    * @memberof MessageApiListAllMessages
    */
    readonly limit?: number
    
    /**
    * The iterator returned from a prior invocation
    * @type {string}
    * @memberof MessageApiListAllMessages
    */
    readonly iterator?: string
    
    /**
    * Filter response based on the channel
    * @type {string}
    * @memberof MessageApiListAllMessages
    */
    readonly channel?: string
    
    /**
    * Only include items created before a certain date
    * @type {string}
    * @memberof MessageApiListAllMessages
    */
    readonly before?: string
    
    /**
    * Only include items created after a certain date
    * @type {string}
    * @memberof MessageApiListAllMessages
    */
    readonly after?: string
    
    /**
    * When `true` message payloads are included in the response
    * @type {boolean}
    * @memberof MessageApiListAllMessages
    */
    readonly withContent?: boolean
    
    /**
    * Filter messages matching the provided tag
    * @type {string}
    * @memberof MessageApiListAllMessages
    */
    readonly tag?: string
    
    /**
    * Filter response based on the event type
    * @type {Set<string>}
    * @memberof MessageApiListAllMessages
    */
    readonly eventTypes?: Set<string>
    
}

/**
 * MessageApiGenerated - object-oriented interface
 * @export
 * @class MessageApiGenerated
 * @extends {BaseAPI}
 */
export class MessageApiGenerated extends BaseAPI {
    /**
     * Creates a new message and dispatches it to all of the application\'s endpoints.  The `eventId` is an optional custom unique ID. It\'s verified to be unique only up to a day, after that no verification will be made. If a message with the same `eventId` already exists for any application in your environment, a 409 conflict error will be returned.  The `eventType` indicates the type and schema of the event. All messages of a certain `eventType` are expected to have the same schema. Endpoints can choose to only listen to specific event types. Messages can also have `channels`, which similar to event types let endpoints filter by them. Unlike event types, messages can have multiple channels, and channels don\'t imply a specific message content or schema.  The `payload` property is the webhook\'s body (the actual webhook message). Svix supports payload sizes of up to ~350kb, though it\'s generally a good idea to keep webhook payloads small, probably no larger than 40kb.
     * @summary Create Message
     * @param {MessageApiCreateNewMsgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApiGenerated
     */
    public createNewMsg(requestParameters: MessageApiCreateNewMsgRequest, options?: AxiosRequestConfig) {
        return MessageApiFp(this.configuration).createNewMsg(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the given message\'s payload. Useful in cases when a message was accidentally sent with sensitive content.  The message can\'t be replayed or resent once its payload has been deleted or expired.
     * @summary Delete message payload
     * @param {MessageApiDeletePayloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApiGenerated
     */
    public deletePayload(requestParameters: MessageApiDeletePayloadRequest, options?: AxiosRequestConfig) {
        return MessageApiFp(this.configuration).deletePayload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a message by its ID or eventID.
     * @summary Get Message
     * @param {MessageApiGetByIdOrEventIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApiGenerated
     */
    public getByIdOrEventId(requestParameters: MessageApiGetByIdOrEventIdRequest, options?: AxiosRequestConfig) {
        return MessageApiFp(this.configuration).getByIdOrEventId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the application\'s messages.  The `before` and `after` parameters let you filter all items created before or after a certain date. These can be used alongside an iterator to paginate over results within a certain window.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * @summary List Messages
     * @param {MessageApiListAllMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApiGenerated
     */
    public listAllMessages(requestParameters: MessageApiListAllMessagesRequest, options?: AxiosRequestConfig) {
        return MessageApiFp(this.configuration).listAllMessages(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
